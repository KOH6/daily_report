## はじめに
達人に学ぶDB設計の感想を記載いたします。

## 良かったところ
* 演習のシチュエーションが具体的

## 学んだこと
### 第1章　データベースを制する者はシステムを制す
* 情報自体はデータのみから得られるものではない。データと文脈を合成して情報が生まれる。
* データベースのモデルが異なれば、フォーマットや設計方法も異なる。
  * 正規化はRDB以外のDBでは通常行わない。
* 一方で、モデルが異なっても「データの整合性保持」「冗長性排除」といった目的は変わらない。
* DBMSが異なってもDBのモデルが同じであれば、基本的に設計の方法は影響を受けない。
* DB設計が重要な理由2つ
  * ①DB設計＝データ設計でほぼ同義となるから
  * ②データ設計がシステム全体の品質を決めるから。ソフトウェアはあくまでデータの流通機構であり、プログラムの設計もデータ設計に左右される。
* DOAとPOA
  * POA(Process Oriented Approach)：プロセス（プログラム）を先に設計する方法論。現在では時代遅れ。
    * プロセス単位でデータ設計を行うため、同じデータをプロセスごとに別個に持つ必要がある。システム全体で見たときに冗長なデータ構造になりがち。処理ごとにデータが分散して管理が大変になる。
  * DOA(Data Oriented Approach)：プログラムより先にデータ設計を行う方法論。近年主流。
    * データを一元管理できるため、データがあまり変化せず永続的になる。複数プログラムで共用することが容易で、仕様変更にも柔軟に対応できる。
  * 「最初にデータありき」のスローガンで考えるべき。
* セオリーを踏む外したデータ設計を行うと、システムの機能/非機能の品質を致命的に損なうことにつながる。
* 3層スキーマモデル
  * 外部スキーマ：ユーザから見たDB
    * 画面のUIや入力データ等ユーザから見えるシステムの姿
  * 概念スキーマ：開発者から見たDB
    * 論理設計でこのスキーマを設計。データの独立性を保証するためにある。
    * **概念スキーマのない2層のスキーマで設計すると、変更に対する柔軟性がなくなる！**
  * 内部スキーマ：DBMSから見たDB
    * 物理設計でこのスキーマを設計。DBMS内のファイルで表現される世界。
* Tips：概念の有用性がわからなくなったら、それがなかったらどうなるかを考えるようにする。長年の試行錯誤により生み出されたものがほとんど。

### 第2章　論理設計と物理設計
* システムの世界の「論理」：「物理層の制約に縛られない」という意味
  * 「物理層の制約」とは、DBサーバーのCPUパワーやDBMSのSQLの構文等実装面も含まれる。DB設計を最初に行う際は、こういう物理層の制約を一旦脇に置いて話を進める。
  * 論理設計→物理設計の順に行うということ
* 論理設計のステップ
  * ①エンティティの抽出
    * エンティティ（現実世界に存在するデータの集合体）を抽出する。要件定義の中で行われるもの。
  * ②エンティティの定義
    * 各エンティティの属性（どのようなデータを持つか）を定義する。
  * ③正規化
    * エンティティを抽出し属性を定義しただけでは、エンティティがシステムの利用に耐えられる状態になっていないため正規化を行う。
  * ④ER図の作成
    * エンティティの見取り図であるER図を作成する。エンティティ同士の関係を表現する。
* 物理設計のステップ
  * ①テーブル定義
    * 論理設計で定義された概念スキーマをもとにテーブルに変換する作業
  * ②インデックス定義
    * 非機能、パフォーマンスに大きく影響するインデックスを定義する作業
  * ③ハードウェアのサイジング
    * キャパシティとパフォーマンスの2つの観点からサイジングを行う。
    * パフォーマンス問題の8割はディスクI/Oによって決まる。
    * DBではデータの生合成とパフォーマンスの間に強いトレードオフが存在する。
    * キャパシティのサイジング
      * この段階ではサービス終了時のデータ量を見積もる必要があるが、なかなか難しい。見積もるためには以下2つのアプローチがある。
      * 1.安全率を大きく取って、余裕を持たせたサイジングをする。
      * 2.容量不足に備えて、簡単に記憶装置を追加できるような構成にしておく。
    * パフォーマンスのサイジング
      * 処理時間（どれだけ速いか）、スループット（どれだけ多いか）の2つが性能要件の指標となる。
      * リソース使用量については、「類似の稼働システムのデータを流用する」「プロトタイプを構築して、性能検証をする」ことにより基礎数値を測る。
    * サイジングについては精度高く行うことは難しい。そのため「実施時に必ず安全率をかける」「スケーラビリティの高い構成を組む」ことが大切になる。
    * サイジングは物理設計の中でも難易度が高いタスク。**サイジングができればDBエンジニアとしてはエース級**
  * ④ストレージの冗長構成決定
    * RAIDという技術を使ってデータの物理的な持ち方を冗長化する。DBに保管されるデータは業務の基幹データなので失うことは許されない。そのため、RAIDという技術を使って高い耐障害性を持つように構築する。RAIDを使うことで、システムの信頼性と性能を共に改善できる。
    * RAIDのパターンは何個か存在するが、DBのRAIDは少なくともRAID5(最低3本で構成、パリティを使用する)で構成する。
    * コストに余裕があれば、RAID10(RAID1とRAID0を組みあわせた構成)で構成する。
    * RAID0(データを異なるディスクに分散するのみの構成)は論外。
  * ⑤ファイルの物理配置決定
    * ファイルの配置については自動化が進んでいるのである程度はDBMSが自動的に配置してくれる。しかし、基本的な考え方を抑えなければトラブルシューティングが困難になる。
* バックアップ設計
  * データ損失の事件を避ける設計には2通りの方針がある。一つは極力データを失わないようRAID設計等を使うこと。2つ目は、データが失われた際に復旧できるようにしておくこと。
  * 主要なバックアップ方式は以下3つ。「フルバックアップ＋差分バックアップ」、「フルバックアップ＋増分バックアップ」が一般的
    * 1.フルバックアップ
    * 2.差分バックアップ
    * 3.増分バックアップ
* リカバリ設計
  * バックアップファイルを戻す作業が「リストア」、トランザクションログを適用して変更分を反映する作業を「リカバリ」という。
  * データ復旧時には、バックアップされていないDBMS内のトランザクションログまで適用する（ロールフォワード）ことで、データを障害直前の状態に復旧できる。

### 第3章　論理設計と正規化 ～なぜテーブルは分割する必要があるのか？
### 第4章　ER図 ～複数のテーブルの関係を表現する
### 第5章　論理設計とパフォーマンス ～正規化の欠点と非正規化
### 第6章　データベースとパフォーマンス
### 第7章　論理設計のバッドノウハウ
### 第8章　論理設計のグレーノウハウ
### 第9章　一歩進んだ論理設計 ～SQLで木構造を扱う

## 難しかったこと
*