## はじめに
達人に学ぶDB設計の感想を記載いたします。

## 良かったところ
* 演習のシチュエーションが具体的
* 後半の章では実例を紹介しながら、バッドノウハウ・グレーな設計ノウハウが紹介されている

## 学んだこと
### 第1章　データベースを制する者はシステムを制す
* 情報自体はデータのみから得られるものではない。データと文脈を合成して情報が生まれる。
* データベースのモデルが異なれば、フォーマットや設計方法も異なる。
  * 正規化はRDB以外のDBでは通常行わない。
* 一方で、モデルが異なっても「データの整合性保持」「冗長性排除」といった目的は変わらない。
* DBMSが異なってもDBのモデルが同じであれば、基本的に設計の方法は影響を受けない。
* DB設計が重要な理由2つ
  * ①DB設計＝データ設計でほぼ同義となるから
  * ②データ設計がシステム全体の品質を決めるから。ソフトウェアはあくまでデータの流通機構であり、プログラムの設計もデータ設計に左右される。
* DOAとPOA
  * POA(Process Oriented Approach)：プロセス（プログラム）を先に設計する方法論。現在では時代遅れ。
    * プロセス単位でデータ設計を行うため、同じデータをプロセスごとに別個に持つ必要がある。システム全体で見たときに冗長なデータ構造になりがち。処理ごとにデータが分散して管理が大変になる。
  * DOA(Data Oriented Approach)：プログラムより先にデータ設計を行う方法論。近年主流。
    * データを一元管理できるため、データがあまり変化せず永続的になる。複数プログラムで共用することが容易で、仕様変更にも柔軟に対応できる。
  * 「最初にデータありき」のスローガンで考えるべき。
* セオリーを踏む外したデータ設計を行うと、システムの機能/非機能の品質を致命的に損なうことにつながる。
* 3層スキーマモデル
  * 外部スキーマ：ユーザから見たDB
    * 画面のUIや入力データ等ユーザから見えるシステムの姿
  * 概念スキーマ：開発者から見たDB
    * 論理設計でこのスキーマを設計。データの独立性を保証するためにある。
    * **概念スキーマのない2層のスキーマで設計すると、変更に対する柔軟性がなくなる！**
  * 内部スキーマ：DBMSから見たDB
    * 物理設計でこのスキーマを設計。DBMS内のファイルで表現される世界。
* Tips：概念の有用性がわからなくなったら、それがなかったらどうなるかを考えるようにする。長年の試行錯誤により生み出されたものがほとんど。

### 第2章　論理設計と物理設計
* システムの世界の「論理」：「物理層の制約に縛られない」という意味
  * 「物理層の制約」とは、DBサーバーのCPUパワーやDBMSのSQLの構文等実装面も含まれる。DB設計を最初に行う際は、こういう物理層の制約を一旦脇に置いて話を進める。
  * 論理設計→物理設計の順に行うということ
* 論理設計のステップ
  * ①エンティティの抽出
    * エンティティ（現実世界に存在するデータの集合体）を抽出する。要件定義の中で行われるもの。
  * ②エンティティの定義
    * 各エンティティの属性（どのようなデータを持つか）を定義する。
  * ③正規化
    * エンティティを抽出し属性を定義しただけでは、エンティティがシステムの利用に耐えられる状態になっていないため正規化を行う。
  * ④ER図の作成
    * エンティティの見取り図であるER図を作成する。エンティティ同士の関係を表現する。
* 物理設計のステップ
  * ①テーブル定義
    * 論理設計で定義された概念スキーマをもとにテーブルに変換する作業
  * ②インデックス定義
    * 非機能、パフォーマンスに大きく影響するインデックスを定義する作業
  * ③ハードウェアのサイジング
    * キャパシティとパフォーマンスの2つの観点からサイジングを行う。
    * パフォーマンス問題の8割はディスクI/Oによって決まる。
    * DBではデータの整合性とパフォーマンスの間に強いトレードオフが存在する。
    * キャパシティのサイジング
      * この段階ではサービス終了時のデータ量を見積もる必要があるが、なかなか難しい。見積もるためには以下2つのアプローチがある。
      * 1.安全率を大きく取って、余裕を持たせたサイジングをする。
      * 2.容量不足に備えて、簡単に記憶装置を追加できるような構成にしておく。
    * パフォーマンスのサイジング
      * 処理時間（どれだけ速いか）、スループット（どれだけ多いか）の2つが性能要件の指標となる。
      * リソース使用量については、「類似の稼働システムのデータを流用する」「プロトタイプを構築して、性能検証をする」ことにより基礎数値を測る。
    * サイジングについては精度高く行うことは難しい。そのため「実施時に必ず安全率をかける」「スケーラビリティの高い構成を組む」ことが大切になる。
    * サイジングは物理設計の中でも難易度が高いタスク。**サイジングができればDBエンジニアとしてはエース級**
  * ④ストレージの冗長構成決定
    * RAIDという技術を使ってデータの物理的な持ち方を冗長化する。DBに保管されるデータは業務の基幹データなので失うことは許されない。そのため、RAIDという技術を使って高い耐障害性を持つように構築する。RAIDを使うことで、システムの信頼性と性能を共に改善できる。
    * RAIDのパターンは何個か存在するが、DBのRAIDは少なくともRAID5(最低3本で構成、パリティを使用する)で構成する。
    * コストに余裕があれば、RAID10(RAID1とRAID0を組みあわせた構成)で構成する。
    * RAID0(データを異なるディスクに分散するのみの構成)は論外。
  * ⑤ファイルの物理配置決定
    * ファイルの配置については自動化が進んでいるのである程度はDBMSが自動的に配置してくれる。しかし、基本的な考え方を抑えなければトラブルシューティングが困難になる。
* バックアップ設計
  * データ損失の事件を避ける設計には2通りの方針がある。一つは極力データを失わないようRAID設計等を使うこと。2つ目は、データが失われた際に復旧できるようにしておくこと。
  * 主要なバックアップ方式は以下3つ。「フルバックアップ＋差分バックアップ」、「フルバックアップ＋増分バックアップ」が一般的
    * 1.フルバックアップ
    * 2.差分バックアップ
    * 3.増分バックアップ
* リカバリ設計
  * バックアップファイルを戻す作業が「リストア」、トランザクションログを適用して変更分を反映する作業を「リカバリ」という。
  * データ復旧時には、バックアップされていないDBMS内のトランザクションログまで適用する（ロールフォワード）ことで、データを障害直前の状態に復旧できる。

### 第3章　論理設計と正規化 ～なぜテーブルは分割する必要があるのか？
* 外部キーの役割はあるテーブルに対して参照整合性制約を課すこと。
* 親レコードがない子レコードを合わせた削除することをカスケードという。
* 常に子テーブルを先に削除・変更して後から親テーブルを更新すればカスケードするかいなかの考慮はそもそも不要になる。
* キーに使用する列はコードやID等の固定長文字列のデータ型にするのがRDBの鉄則。
* テーブル定義において、列には可能な限りNOT NULL制約を付与するべし。

#### 正規化について
* 正規化とはDBのデータの冗長性を排除し、一貫性と効率性をもったデータ形式にすること。正規形は第5レベルまであるが、普通は第3世紀形まで理解すれば十分。
  * 第1正規形：一つのセルの中に一つの値しか含まないようにする。
  * 第2正規形：部分関数従属（主キーの一部に従属する列が存在する）を解消する。
  * 第3正規形：推移的関数従属（何段階かで従属する列が存在する）を解消する。
  * ボイスーコッド正規形：非キーからキーへの関数従属をなくした状態にする。分解時に気をつけないと不可逆な操作となることがある。
  * 第4正規形：多値従属性が複数存在するテーブルを分割する。
  * 第5正規形：関連と関連エンティティを1対1になるようにテーブルを分割する。
* 正規化の逆操作は結合。正規化は基本的に可逆的な操作。
* 正規化によりデータの冗長性を排除するとテーブル数が自ずと増える。そのため、SQL文で結合を多用することになりパフォーマンスが悪化する。

### 第4章　ER図 ～複数のテーブルの関係を表現する
* ER図の代表的なフォーマットは、「IE表記法」と「IDEFIX」の2つ。
  * IE表記のほうが簡素で概略が把握しやすい。IDEFIXはかなり細かく記述できる。
* RDBのお約束として多対多の関連は作ってはならない。こういう場合は、関連実体を使用して解消する。
* 複数のエンティティと対応するレコード数をカーディナリティという。
* 他のテーブルに依存しない独立エンティティと依存する従属エンティティの区別は主キーに外部キーが含まれるかでわかる。

### 第5章　論理設計とパフォーマンス ～正規化の欠点と非正規化
* 正規化されたテーブルへのSQLは結合を多用することになるので、非常にパフォーマンスが悪くなる。
* 正規化の次数が低いほど検索SQLのパフォーマンスは良いが、データ整合性は低くなる。
* 意図的に非正規化することで、SQLで結合を使わずに済む。更新時には、非正規化するとレコード数が増えてパフォーマンスが悪くなることも多い。
* 非正規化は、切羽詰まった時にとる最後の手段（しかも劇薬）と考えるべき。
* その他、正規化にによって結合が必要になるためパフォーマンス悪化するパターン。
  * サマリデータの冗長性排除：サマリデータを冗長に保持すると非正規化になるが、検索を高速化できる。
  * 選択条件の冗長性排除：選択条件を冗長に保持すると非正規化になるが、検索を高速化できる。
* **非正規化は慎重に実施するべきで難しい作業。それゆえ、エンジニアの本務である。**
* 非正規化のリスク3つ
  * 1.検索パフォーマンスは向上するが更新パフォーマンスは低下する。
  * 2.データのリアルタイム性が低下する。更新タイミングに注意。
  * 3.後続の工程で設計変更すると、手戻りが大きい。
* 論理設計の際には、「システムの品質・開発が成功するかは今ここで決まる！」という気概で臨む必要がある。
* 論理設計をする際には物理設計の知識も必要になる。

### 第6章　データベースとパフォーマンス
### 第7章　論理設計のバッドノウハウ
### 第8章　論理設計のグレーノウハウ
### 第9章　一歩進んだ論理設計 ～SQLで木構造を扱う

## 難しかったこと
*