## はじめに
プロを目指す人のためのRuby入門［改訂2版］（通称：チェリー本）を読んで学んだこと

## 学んだこと
* Rubyにはプリミティブな型がなく全てオブジェクト。

###  2章
* 可読性が下がる場合があるので、多重代入はむやみに使用せず適切な場面で利用する
* 改行文字`\n`を埋め込みたい場合はダブルクォートを使う必要がある。
* ダブルクォートを使うと式展開が使える。
* 基本的にダブルクォート、シングルクォートどちらを使っても問題ないが、コーディング規約では指定される場合があるので注意。
* 数値に`_`を含めることができる。
* `++`や`--`のような演算子はない。
* 数値と文字列は暗黙的に変換されない。
* 丸め誤差を防ぐためにはRationalクラスを使用する。
* Rubyでは「nilも偽」という性質を生かしたコードが頻出。
* Rubyは最後に評価された式がメソッドの戻り値になるのが特徴。returnはメソッドを途中で脱出する際に使われることが多い。
* 引数がない場合はメソッドに()をつけない方が主流。
* ヒアドキュメントで複数行に渡る文字列を記述できる。
* %記法でも文字列を作ることができる。
* Rubyでは文字と文字列に違いはない。
* Rubyではif文以外のところで`&&`や`||`を意図的に使う場合がある。
* `and`や`or`は条件分岐で使うのではなく、制御フローとして使用するのに向いている。
* Rubyのcase文ではwhen節に複数の値を指定できる。また、breakを使わなくても次の処理が実行されることはない。
* 真偽値を返すようなメソッドを作る場合は、メソッド名は`?`で終わらせた方が良い。
* 「!で終わるメソッドは破壊的メソッドである」は間違いである場合がある。
* 配列のsize、lengthのように全く同じ実装で名前だけ異なるメソッドをエイリアスメソッドと呼ぶ。
* `puts,print`メソッドは一般ユーザ向け、`p,pp`メソッドは開発者向け

###  3章
* プログラマの三代美徳は「怠惰・短気・傲慢」

###  4章
* delete_ifメソッドでeachメソッドと同じように、配列の要素を順番に取り出すことができる。
* `<<`を使うと配列の最後に要素を追加することができる。
* joinメソッドを使うと配列に数値が含まれていても連結可能（to_sメソッドで文字列に変換されるため。）
* 単純な場合はsumよりjoinを使った方がわかりやすい。ただし、sumを使うと空文字列以外の初期値（先頭の文字列）を与えたり、ブロック内で文字列の加工が可能になる。
```rb
['a', 'b', 'c'].sum('>') {|c| c.upcase} #=> ">ABC"
```
* &とシンボルでブロックを使うメソッドはもっと簡潔に書くことができる。以下の3つを満たすとき簡潔に書ける。
  * ブロックパラメータが1つだけ。
  * ブロックの中で呼び出すメソッドに引数がない。
  * ブロックの中で、ブロックパラメータに対してメソッドを1回呼び出す以外の処理がない。
* `1..5`や`'a'..'e'`という範囲オブジェクトがある。
* 範囲オブジェクトに対して直接eachメソッドを呼び出すことも可能
* テスト駆動開発では以下のサイクルが基本となる。
  * 先にテストを書いて失敗させる。
  * テストがパスできる最小限のコードを書く。
  * リファクタリングする。
* Rubyでは添字に負の数字が使える。-1は最後の要素、-2は最後から２番目の要素。
* 配列のlastメソッドにより、配列の最後の要素を取得できる。
* 2つの配列を連結したい場合はconcatメソッドか、+演算子を使う。concatは破壊的で、+演算子は破壊的でない。+演算子を基本的に使う。
* メソッドの引数に配列を渡すとき、配列を展開して「複数の引数」として渡したい場合は、配列の前に*(splat演算子)をおく。
* 配列に対して==で比較すると、全要素が全て等しい場合に等しいという判定になる。
* 配列のメソッドを探すときは、ArrayクラスとEnumerableモジュールの両方のリファレンスに目を通す。
* Rubyのthrow、catchは例外処理とは関係ない。
* breakは繰り返し処理からの脱出、returnはメソッドからの脱出。

###  5章
* ハッシュの同値比較は、並び順が異なっていてもkey,valueが全て同じなら同値扱い。
* シンボルはハッシュのキー等でよく使われる。シンボルの特徴は以下。
  * コード上は文字列なので可読性が高い。
  * 内部的には整数なので、コンピュータは高速に値比較ができる。
  * 同じシンボルは同じオブジェクトになるため、メモリの使用効率が良い。
  * イミュータブルなので、値を変えられる心配がない。
```rb
# シンボルを使ったハッシュの作成方法
currencies = {japan: 'yen', us: 'dollar', india: 'rupee'}
```
* キーワード引数を使うと、メソッド呼び出し時にどの引数がどんな意味を持つかわかりやすくなる
```rb
# キーワード引数を使ったメソッド呼び出し
buy_burger('cheese', drink: true, potato: true)
```
* `**`をハッシュの前につけるとハッシュリテラル内で他のハッシュの要素を展開できる。
* 最後の引数がハッシュであれば、ハッシュリテラルの{}を省略できる。
* ハッシュリテラルの{}の前後で構文エラーが発生した場合は、()の省略が原因になっていないか確認する。
* Hash.newのブロックパラメータで2つのパラメータを使うことで、ハッシュにキーとデフォルト値を同時に設定できる。
```rb
# デフォルト値を返すだけでなく、ハッシュに指定されたキーとデフォルト値を同時に設定する。
h = Hash.new { |hash, key| hash[key] = 'hello' }
```
* %sを使うことでもシンボルを作成することができる。
* nilかもしれないオブジェクトに対して安全にメソッドを呼び出すときは`&.`演算子を使うことができる。（他言語のOptional Chainingっぽいもの？）
* `X ||= A`で変数Xがnilまたはfalseなら、AをXに代入(nilガード)
* 「確実にtrueまたはfalseを返したい場合」や「trueまたはfalseに変換したい場合」には、`!!`を使う。

###  6章
* `=~`を使うと、正規表現がマッチした場合は文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなかった場合はnilが返る。
* 正規表現のキャプチャ機能を使う方法の一つはmatchメソッドを使うこと。
* キャプチャの結果には以下のように名前をつけることができる。こうすることで何番目の値か気にする必要がない。
```rb
text = '私の誕生日は1977年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>d+)日/.match(text)
# シンボルで名前を指定してキャプチャの結果を取得する。
m[:year] #=> "1977"
```
* 左辺に正規表現リテラル、右辺に文字列を置いて=~演算子を使うと、キャプチャの名前がそのままローカル変数に割り当てられる。
  * ただし、この機能は左辺と右辺を逆にすると使えない。また、正規表現オブジェクトをいったん変数に入れた場合も使えない。
```rb
text = '私の誕生日は1977年7月17日です。'
if /(?<year>\d+)年(?<month>\d+)月(?<day>d+)日/ =~ text
  puts "#{year}/#{month}/#{day}" #=> 1977/7/17
end
```
* $1や$2のような組み込み変数はgsubメソッドなどでよく使われる。
* scanメソッドは引数で渡した正規表現にマッチする部分を配列に入れて返す。
```rb
'123 456 789'.scan(/\d+/) #=> ["123", "456", "789"]
```
* []に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出す。
* sliceメソッドは[]のエイリアスメソッド。slice!にするとマッチした部分が文字列から破壊的に取り除かれる。
* splitに正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返す。
* gsubメソッドを使うと、第一引数の正規表現にマッチした文字列を第二引数の文字列で置き換える。gsub!にすると、破壊的に置換する。
* gsubやgsub!では第2引数の代わりにブロックを使って文字列を置換できる。

###  7章(7.1〜7.6)
* ハッシュは新しくキーを追加したり、内容を変更できるので「もろくて壊れやすいプログラム」になりがち
* また、大きなプログラムになるとハッシュのみでの管理は困難になるため、クラスの存在が大事になる。
* クラスに関連は深いものの、一つ一つのインスタンスに含まれるデータを使わないメソッドを定義した場合はクラスメソッドを使う。
* `class << self`を使って暮らすメソッドを定義した場合、ネストは一段深くなる。その代わりに、複数のクラスメソッドを定義する際に毎回self.をつけなくて済む。
* `String#to_i`でStringクラスのto_iというインスタンスメソッドを表す。
* `File.exist?`または`File::exist?`でFileクラスのexist?というクラスメソッドを表す。
* `||=`のnilガードを使ったテクニック
  * データをメモ化することができる。
  * 遅延初期化によりプログラムのパフォーマンスを最適化できる
* メソッド内で`name=`のようなセッターメソッドを呼び出すときは必ずselfをつける必要がある。
* Rubyではクラス定義も上から順に実行される。そのため、クラス構文直下でクラスメソッドを呼び出すことができる。
* Rubyでは継承できるスーパークラスは1つだけ。ただしミックスインという多重継承に似た機能がある。
* 継承関係を含めてクラスを確認した場合はis_a?かkind_of?メソッドを使う。
* スーパークラスとサブクラスで引数の数が同じだった場合は、引数なしのsuperを呼ぶだけで自分に渡された引数をスーパークラスに渡すことができる。
* インスタンスメソッドに比べると、継承されたクラスメソッドを使うことは少ない。
* 引数が`(*)`だけのメソッド定義の意図2つ
  * superメソッドに引数をそのまま全部渡す
  * 余分に渡された引数を無視する

###  7章(7.7〜)
* Rubyの可視性はJavaとは少し異なる。
* privateメソッドはそのクラスだけでなく、サブクラスでも呼び出せる。
  * 意図せず偶然スーパークラスのprivateメソッドをオーバーライドすることが起こりうる。Rubyで継承する際には、スーパークラスの実装も把握する必要がある。
  * サブクラスでメソッドをオーバーライドすると、可視性も同時に変更できる。意図せず可視性を変更しないように注意。
* クラスメソッドをprivateの下に書いてもprivateにならない。
  * `class << self`の構文を使うか、`private_class_method`を使う。
* Rubyのメソッド定義は式になっている。戻り値はメソッド名をシンボルとして返す。privateキーワードもメソッドで引数が設定できるため下記の書き方が成立する。
```rb
Class User
  private def foo
    `foo`
  end
end
```
* Ruby3.0では`private attr_accessor :name`でprivateなアクセサメソッドを定義できる
* protectedは、外部に公開はしたくないが同じクラスやサブクラスの中であればレシーバ付きで呼び出せるようにしたい。という時に使う。
  * protectedの使用頻度は少ない。
* 外部から参照する必要がない定数でもpublicのままにしているコードもよくある。
* 定数の定義は必ずクラス構文の直下、もしくはトップレベルで行う必要がある。
* 定数には再代入が可能。
* Rubyの定数は「絶対変更できない値」ではなく、「変更しようと思えばいくらでも変更できる値」になっている。ついうっかりの事故を防ぐため、幾らかの工夫が必要になる。
* クラスインスタンス変数とクラス変数は、インスタンス変数に比べると使用頻度は少ない。
* グローバル変数の乱用は可読性の低いコードを作ることに繋がる。使用を避けるべき。
* クラスの可読性をprivateにしたい場合は、`private_constant`を使う。
* Rubyには抽象クラスやインターフェースは存在しない。

###  8章
* 継承は使えないが、特定の共通機能を持たせたい場合にはモジュールが選択肢に挙がる。
* includeすると、インスタンスメソッドとして呼び出せる。
* モジュール側でprivateとして定義すると、includeしたクラスでもprivateメソッドとして扱われる。
* extendすると、特異メソッド（クラスメソッド）として呼び出せる。
* includeやextendはクラス名.include、クラス名.extendで呼び出すことも可能
* クラスオブジェクトにinclude?メソッドを呼ぶと、引数で渡したモジュールがincludeされているかどうかわかる。
* included_modulesメソッドを呼ぶと、includeされているモジュールの配列が返る。
* ancestorsメソッドを使うと、モジュールだけでなくスーパークラスの情報も配列になって返る。
* include先のクラスでeachメソッドが実装されている場合、Enumerableモジュールをincludeできる。
* include先のクラスで<=>演算子が実装されている場合、Comparableモジュールをincludeできる。
* Rubyは全てがオブジェクトのため、クラスやモジュールもオブジェクト。
* ミックスイン先のクラスと連携する場合は、特定インスタンス変数より特定メソッドの存在を前提とするほうが安全。これは、メソッドは未定義の場合エラーが発生するため安全性が高まるからである。
* モジュール構文の中にクラス定義を書くと「そのモジュールに属するクラス」という意味になり、名前の衝突を防ぐことができる。
* 名前空間は、クラスのグループ分け・カテゴリ分けをする目的で使われる場合もある。
* モジュールはインスタンスを作れないため、newせずに単なるメソッドの集まりを作りたいケースに向いている。
* module_functionメソッドで、メソッドインとしても特異メソッドとしても使える一石二鳥なメソッドを定義可能。
  * module_functionでモジュール関数となったメソッドは、ミックスインするとprivateメソッドになる。
* モジュールにも定数を定義することができる。
* 状態を保持するモジュールの作成も可能。クラスでも可能であるが、インスタンス化が不要な場合はモジュールにしておいた方が勘違いが減る。
* include以外にprependでもインスタンスメソッドとしてミックスインできる。prependでは同名のメソッドがあったとき、先にモジュールのメソッドが呼ばれるようになる。
  * prependを使うことで、オリジナルの実装を生かした既存メソッドの置き換えが可能

###  9章
* 通常のプログラムで捕捉するのはStandardErrorクラスか、そのサブクラスに限定するべき。
* rescueにExceptionクラスを指定するのはRubyにおいては好ましくないコードになる。
* retryで例外発生時に処理をやり直すことができる。無限ループになりうるのでカウンタ変数を使用する。
* 例外を発生させる際はraiseメソッド
* すべての例外をrescueする必要はなく。rescueすべき例外の方が少ない。
* 例外が発生したらrescueするよりも、「例外が発生したら即座に異常終了させよう」、「フレームワークの共通処理に全部丸投げしよう」と考える方が安全。
* rescueする場合、最低でも発生した例外のクラス名、エラーメッセージ、バックトレースの3つはログやターミナルに出力するべき。これらの情報はfull_messageメソッドで一度に取り出せる。
* 微妙におかしい状態でプログラムを実行するよりも、できるだけ早い段階で例外を発生させてプログラムを緊急停止させた方が良い不具合と言える。
* ファイル処理のような「使用したらリソースを解放する」ものはRubyではブロック付きのメソッドが使えるケースが多い。ensureを使う前に、公式リファレンスを確認すべき。
* rescueは修飾子としても使える。例外が発生しなければ元の処理の値を返す。例外が発生した場合はrescue修飾子に書いた値が返る。
```rb
1 / 0 rescue 0 #=> 0
```
* 例外処理を細かく制御したい場合は、rescue修飾子ではなくbegin~endを使った例外処理を書くほうがよい。

###  10章
* ブロックが渡されたどうかを確認する場合はblock_given?メソッドを使う。
* ブロックをメソッドの引数として明示的に受け取ることができる。この際は`メソッド(&引数)`とする。
* ブロックを引数に渡すメリット
  * ブロックを他のメソッドに引き渡せるようになること。
  * 渡されたブロックに対してメソッドを呼び出し、必要な情報取得、ブロックに対する何かしらの操作を実行できる。
* Proc.newとラムダはほぼ同じものだが、微妙な違いがある。
  * 一番重要な違いは引数の扱い方で、ラムダの場合は引数に過不足があるとエラーになる。

###  11章
* パターンマッチ(case/in式)のin節で値を省略してキーだけを書いた場合は、自動的にキーと同じローカル変数が作成され、そこに値が代入される。
* パターンマッチの大きな特徴
  * 配列やハッシュの構造をパターン化して条件分岐させるところ
  * in節で=を使わずにローカル変数の宣言と代入が行われる
* 想定しない条件で意図的に例外をraiseするコードを書く際には、自動的に例外が発生するパターンマッチを使った方がシンプルに書ける。

###  12章
* pメソッドを使うとターミナルへの出力と変数への代入を一度に行うこともできる。
* tapメソッドをメソッドチェーンの途中に挟むことで、途中の値を確認可能。

###  13章
* Railsの知識とRubyの知識は分けて考える。
* Railsのインスタンス変数は、Railsの規約としてインスタンス変数が採用されているだけ。オブジェクト指向プログラミングのインスタンス変数とは分けて考えるべき。